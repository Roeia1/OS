roeia1, maayanimi
Roei Avrahami (304986714), Maayan Mizrahi (304901259)
EX: 5

FILES:

clftp.cpp			- The client.
srftp.cpp			- The server.
helper.h			- Helper file which contain functions and consts.
helper.cpp			- Implementation of helper.h
Makefile            - The makeFile.
README              - this file.
performance.jpg		- Performance evaluation.

REMARKS:

In this ex we're implementing a TCP protocol for sending files from
a client to a server.
First we sent the file size for validating if it is a legal size for the server.
Then, we sent the new name of the file that will be created in the server
(first the name size and then the name itself),
and after we send the content of the file.
We sent the data in packets of 4096 bytes.
After we finished sending the file we closed the client socket.

ANSWERS:

Implementing using UDP connection :
	Our UDP protocol will use message numbering identification
	(IP and port num as we learned in the tirgul, and the packet number).
	This identification will let the receiver know from where the message from
	and the number of the packet.
	The sender will know the message arrived.
	After connection being established, the client will send the number
	of packets that he is going to send to the server.
	Then, the client will wait for a ack from the server,
	and if the ack wasn't received the client will send it again.
	Once the ack confirmed at the client, he will start sending the
	packets 5 each time when each packet will be numbered.
	After sending those 5 packets he wait for ack before sending the next 5,
	if no ack he will send all of them again.
	If the ack won't be ok it will say which packets were lost and the client
	will send them again plus the next packets that the sum will be always 5
	(for example if 3 lost he will send those 3 again with 2 squential packets
	of the previous 5).
	Finally, if the ack is ok it will next the next 5 packets.
	From the server side, for each 5 packets he receives he will check if
	the packet's numbers sequential to the previous last packet that already received,
	or one of the "lost" packets he needs to fill.
	If still there are still "lost" packets needed to be fill, the server
	will send to the client the numbers of these packets with the ack,
	if not he will send an ok ack.
	This way if there are 5 "lost" packets he will request all of them
	and the client will only send these 5 again and wont send new ones.
	If a defined time passed and the server don't get packets
	from the client, it will re send the previous ack to the client again.
	When the server received all the packets according to the number
	that received in the beginning, the socket will be closed.
Efficiency:
	In this way we are sending 5 packets at a time, and if some
	packets "lost" in the UDP we will send those the next time,
	while completing the 5 packets with new ones if those that "lost"
	are less then 5.
	This is more efficient then waiting for ack for each packet
	because we sending more data each time
	(assuming that there will be a few "lost" packets).
Differences:
	In this ex we send the file's size, but in the UDP protocol
	we send the num of packets that are going to be sent by the client
	and verify in the end that all these packets arrived.
	Another difference is the waiting and ack every 5 packets
	and recovering "lost" packets by requesting those again.

Analysis:
	In the graph we can clearly see that the dependency of the transmission
	time in the file size is linear, meaning that the bigger the file gets,
	the transmission time will be longer in a linear way.
	In conclusion, the growth rate of the transmission time will be equal
	for different file sizes since its linear.
